plot(svp,data=xtrain)
# Predict labels on test
ypred = predict(svp,xtest)
table(ytest,ypred)
# Compute accuracy
sum(ypred==ytest)/length(ytest)
# Compute at the prediction scores
ypredscore = predict(svp,xtest,type="decision")
# Check that the predicted labels are the signs of the scores
table(ypredscore > 0,ypred)
# Package to compute ROC curve, precision-recall etc...
library(ROCR)
pred <- prediction(ypredscore,ytest)
# Plot ROC curve
perf <- performance(pred, measure = "tpr", x.measure = "fpr")
plot(perf)
# Plot precision/recall curve
perf <- performance(pred, measure = "prec", x.measure = "rec")
plot(perf)
# Plot accuracy as function of threshold
perf <- performance(pred, measure = "acc")
plot(perf)
install.packages("ROCR")
n <- 150 # number of data points
p <- 2 # dimension
sigma <- 1 # variance of the distribution
meanpos <- 0 # centre of the distribution of positive examples
meanneg <- 3 # centre of the distribution of negative examples
npos <- round(n/2) # number of positive examples
nneg <- n-npos # number of negative examples
# Generate the positive and negative examples
xpos <- matrix(rnorm(npos*p,mean=meanpos,sd=sigma),npos,p)
xneg <- matrix(rnorm(nneg*p,mean=meanneg,sd=sigma),npos,p)
x <- rbind(xpos,xneg)
# Generate the labels
y <- matrix(c(rep(1,npos),rep(-1,nneg)))
# Visualize the data
plot(x,col=ifelse(y>0,1,2))
legend("topleft",c('Positive','Negative'),col=seq(2),pch=1,text.col=seq(2))
## Prepare a training and a test set ##
ntrain <- round(n*0.8) # number of training examples
tindex <- sample(n,ntrain) # indices of training samples
xtrain <- x[tindex,]
xtest <- x[-tindex,]
ytrain <- y[tindex]
ytest <- y[-tindex]
istrain=rep(0,n)
istrain[tindex]=1
# Visualize
plot(x,col=ifelse(y>0,1,2),pch=ifelse(istrain==1,1,2))
legend("topleft",c('Positive Train','Positive Test','Negative Train','Negative Test'),
col=c(1,1,2,2),pch=c(1,2,1,2),text.col=c(1,1,2,2))
# load the kernlab package
library(kernlab)
# train the SVM
svp <- ksvm(xtrain,ytrain,type="C-svc",kernel='vanilladot',C=100,scaled=c())
svp
# Attributes that you can access
attributes(svp)
# For example, the support vectors
alpha(svp)
alphaindex(svp)
b(svp)
# Use the built-in function to pretty-plot the classifier
plot(svp,data=xtrain)
# Predict labels on test
ypred = predict(svp,xtest)
table(ytest,ypred)
# Compute accuracy
sum(ypred==ytest)/length(ytest)
# Compute at the prediction scores
ypredscore = predict(svp,xtest,type="decision")
# Check that the predicted labels are the signs of the scores
table(ypredscore > 0,ypred)
# Package to compute ROC curve, precision-recall etc...
library(ROCR)
pred <- prediction(ypredscore,ytest)
# Plot ROC curve
perf <- performance(pred, measure = "tpr", x.measure = "fpr")
plot(perf)
# Plot precision/recall curve
perf <- performance(pred, measure = "prec", x.measure = "rec")
plot(perf)
# Plot accuracy as function of threshold
perf <- performance(pred, measure = "acc")
plot(perf)
library(ROCR)
pred <- prediction(ypredscore,ytest)
ypredscore = predict(svp,xtest,type="decision")
plot(svp,data=xtrain)
library(kernlab)
# train the SVM
svp <- ksvm(xtrain,ytrain,type="C-svc",kernel='vanilladot',C=100,scaled=c())
xtrain <- x[tindex,]
n <- 150 # number of data points
p <- 2 # dimension
sigma <- 1 # variance of the distribution
meanpos <- 0 # centre of the distribution of positive examples
meanneg <- 3 # centre of the distribution of negative examples
npos <- round(n/2) # number of positive examples
nneg <- n-npos # number of negative examples
# Generate the positive and negative examples
xpos <- matrix(rnorm(npos*p,mean=meanpos,sd=sigma),npos,p)
xneg <- matrix(rnorm(nneg*p,mean=meanneg,sd=sigma),npos,p)
x <- rbind(xpos,xneg)
# Generate the labels
y <- matrix(c(rep(1,npos),rep(-1,nneg)))
# Visualize the data
plot(x,col=ifelse(y>0,1,2))
legend("topleft",c('Positive','Negative'),col=seq(2),pch=1,text.col=seq(2))
## Prepare a training and a test set ##
ntrain <- round(n*0.8) # number of training examples
tindex <- sample(n,ntrain) # indices of training samples
xtrain <- x[tindex,]
xtest <- x[-tindex,]
ytrain <- y[tindex]
ytest <- y[-tindex]
istrain=rep(0,n)
istrain[tindex]=1
# Visualize
plot(x,col=ifelse(y>0,1,2),pch=ifelse(istrain==1,1,2))
legend("topleft",c('Positive Train','Positive Test','Negative Train','Negative Test'),
col=c(1,1,2,2),pch=c(1,2,1,2),text.col=c(1,1,2,2))
# load the kernlab package
library(kernlab)
# train the SVM
svp <- ksvm(xtrain,ytrain,type="C-svc",kernel='vanilladot',C=100,scaled=c())
svp
# Attributes that you can access
attributes(svp)
# For example, the support vectors
alpha(svp)
alphaindex(svp)
b(svp)
# Use the built-in function to pretty-plot the classifier
plot(svp,data=xtrain)
# Predict labels on test
ypred = predict(svp,xtest)
table(ytest,ypred)
# Compute accuracy
sum(ypred==ytest)/length(ytest)
# Compute at the prediction scores
ypredscore = predict(svp,xtest,type="decision")
# Check that the predicted labels are the signs of the scores
table(ypredscore > 0,ypred)
# Package to compute ROC curve, precision-recall etc...
library(ROCR)
pred <- prediction(ypredscore,ytest)
# Plot ROC curve
perf <- performance(pred, measure = "tpr", x.measure = "fpr")
plot(perf)
# Plot precision/recall curve
perf <- performance(pred, measure = "prec", x.measure = "rec")
plot(perf)
# Plot accuracy as function of threshold
perf <- performance(pred, measure = "acc")
plot(perf)
n <- 150 # number of data points
p <- 2 # dimension
sigma <- 1 # variance of the distribution
meanpos <- 0 # centre of the distribution of positive examples
meanneg <- 3 # centre of the distribution of negative examples
npos <- round(n/2) # number of positive examples
nneg <- n-npos # number of negative examples
# Generate the positive and negative examples
xpos <- matrix(rnorm(npos*p,mean=meanpos,sd=sigma),npos,p)
xneg <- matrix(rnorm(nneg*p,mean=meanneg,sd=sigma),npos,p)
x <- rbind(xpos,xneg)
# Generate the labels
y <- matrix(c(rep(1,npos),rep(-1,nneg)))
# Visualize the data
plot(x,col=ifelse(y>0,1,2))
legend("topleft",c('Positive','Negative'),col=seq(2),pch=1,text.col=seq(2))
## Prepare a training and a test set ##
ntrain <- round(n*0.8) # number of training examples
tindex <- sample(n,ntrain) # indices of training samples
xtrain <- x[tindex,]
xtest <- x[-tindex,]
ytrain <- y[tindex]
ytest <- y[-tindex]
istrain=rep(0,n)
istrain[tindex]=1
# Visualize
plot(x,col=ifelse(y>0,1,2),pch=ifelse(istrain==1,1,2))
legend("topleft",c('Positive Train','Positive Test','Negative Train','Negative Test'),
col=c(1,1,2,2),pch=c(1,2,1,2),text.col=c(1,1,2,2))
# load the kernlab package
library(kernlab)
# train the SVM
svp <- ksvm(xtrain,ytrain,type="C-svc",kernel='vanilladot',C=100,scaled=c())
svp
# Attributes that you can access
attributes(svp)
# For example, the support vectors
alpha(svp)
alphaindex(svp)
b(svp)
# Use the built-in function to pretty-plot the classifier
plot(svp,data=xtrain)
# Predict labels on test
ypred = predict(svp,xtest)
table(ytest,ypred)
# Compute accuracy
sum(ypred==ytest)/length(ytest)
# Compute at the prediction scores
ypredscore = predict(svp,xtest,type="decision")
# Check that the predicted labels are the signs of the scores
table(ypredscore > 0,ypred)
# Package to compute ROC curve, precision-recall etc...
library(ROCR)
pred <- prediction(ypredscore,ytest)
# Plot ROC curve
perf <- performance(pred, measure = "tpr", x.measure = "fpr")
plot(perf)
# Plot precision/recall curve
perf <- performance(pred, measure = "prec", x.measure = "rec")
plot(perf)
# Plot accuracy as function of threshold
perf <- performance(pred, measure = "acc")
plot(perf)
GWAS_tumor_EPI_ref_QC <- read.table("~/Copy/data/DataEPICURO/GWAS_tumor_EPI_ref_QC.RData", quote="\"")
View(GWAS_tumor_EPI_ref_QC)
install.packages("WGCNA")
library(WGCNA)
options(stringsAsFactors = FALSE);
load("Simulated-dataSimulation.RData");
data(BrainLists);
listGenes = unique(as.character(BrainLists[,1]))
listGenes
set.seed(100)
geneR = sort(sample(listGenes,2000))
categories = sort(rep(standardColors(10),200))
categories[sample(1:2000,200)] = "grey"
write(c("TESTLIST1",geneR[300:400], sep="\n"),"TESTLIST1.txt")
write(c("TESTLIST2",geneR[800:1000],sep="\n"),"TESTLIST2.txt")
# Now run the function!
testResults = userListEnrichment(geneR, labelR=categories,
fnIn=c("TESTLIST1.txt","TESTLIST2.txt"),
catNmIn=c("TEST1","TEST2"),
nameOut = "testEnrichment.csv",useBrainLists=TRUE, omitCategories ="grey")
testResults$sigOverlaps
testResults$ovGenes$"black -- TESTLIST1__TEST1"
testResults$ovGenes$"red -- salmon_M12_Ribosome__HumanMeta"
head(testResults$pValue)
GLIO_Methy_Expression <- read.delim("~/Copy/data/similarity network fusion/nmeth.2810-S3/GBM/GLIO_Methy_Expression.txt")
View(GLIO_Methy_Expression)
data(BrainLists);
dim(BrainLists)
View(BrainLists)
listGenes = unique(as.character(BrainLists[,1]))
set.seed(100)
geneR = sort(sample(listGenes,2000))
geneR
categories = sort(rep(standardColors(10),200))
categories[sample(1:2000,200)] = "grey"
write(c("TESTLIST1",geneR[300:400], sep="\n"),"TESTLIST1.txt")
getwd()
testResults = userListEnrichment(geneR, labelR=categories,
fnIn=c("TESTLIST1.txt","TESTLIST2.txt"),
catNmIn=c("TEST1","TEST2"),
nameOut = "testEnrichment.csv",useBrainLists=TRUE, omitCategories ="grey")
write(c("TESTLIST1",geneR[300:400], sep="\n"),"TESTLIST1.txt")
write(c("TESTLIST2",geneR[800:1000],sep="\n"),"TESTLIST2.txt")
testResults = userListEnrichment(geneR, labelR=categories,
fnIn=c("TESTLIST1.txt","TESTLIST2.txt"),
catNmIn=c("TEST1","TEST2"),
nameOut = "testEnrichment.csv",useBrainLists=TRUE, omitCategories ="grey")
testResults$sigOverlaps
View(testResults)
setwd("~/Documents/rcode/thr33some")
source("load_data.R")
source("build_expr_expr_net.R")
net = build_expr_expr_net("./data/expression_data_scaled_samples_199_genes_499.csv",
start=316, end=318,ncpu=4)
net = build_expr_expr_net("./data/expression_data_scaled_samples_199_genes_499.csv",
start=316, end=418,ncpu=4)
net = build_expr_expr_net("./data/expression_data_scaled_samples_199_genes_499.csv",
start=142, end=242,ncpu=4)
GLIO_Gene_Expression <- read.delim("./data/GBM/GLIO_Gene_Expression.txt", header=F)
expr = as.data.frame(t(GLIO_Gene_Expression))
indexpr = as.character(expr[-1,1])  # samples
namesexpr = {}                      # names of genes from expression dataset
namesline = expr[1,-1]
exprdata = expr[-1,-1]              # raw expression data
exprdata= exprdata[-dim(exprdata)[1], ]   # remove NAs
p = length(namesline)
for(i in 1:p)
{
nameidx = length(levels(namesline[,i]))
namesexpr = c(namesexpr, levels(namesline[[i]])[nameidx])
}
View(exprdata)
GeneExpression <- read.delim("./data/GBM/GLIO_Gene_Expression.txt", header=T)
View(GeneExpression)
GLIO_Methy_Expression <- read.delim("~/Copy/data/similarity network fusion/nmeth.2810-S3/GBM/GLIO_Methy_Expression.txt", header=F)
View(GLIO_Methy_Expression)
datasetmarkers_hgvrs1613 <- read.csv("~/Downloads/datasetmarkers_hgvrs1613.csv", header=F)
View(datasetmarkers_hgvrs1613)
genes <- read.delim("~/Copy/data/RNAseqPACOREAL/8hours/BIG408/genes.fpkm_tracking")
View(genes)
genes.fpkm_tracking <- read.delim("~/Copy/data/RNAseqPACOREAL/8hours/BIG410/genes.fpkm_tracking.gz")
View(genes.fpkm_tracking)
View(genes.fpkm_tracking)
genes$gene_id[1]
genes$gene_id[1] in genes.fpkm_tracking$gene_id
gid = genes$gene_id
class(gid)
gid
which(genes.fpkm_tracking$gene_id == gid[1])
which(genes.fpkm_tracking$gene_id == gid[2])
which(genes.fpkm_tracking$gene_id == gid[3])
which(genes.fpkm_tracking$gene_id == gid)
source("http://bioconductor.org/biocLite.R")
biocLite("GenomicRanges")
source("http://bioconductor.org/biocLite.R")
biocLite("DESeq")
install.packages(c("Rcpp", "gss", "matrixStats", "mice"))
source("http://bioconductor.org/biocLite.R")
biocLite("DESeq")
source("http://bioconductor.org/biocLite.R")
biocLite("edgeR")
source("http://bioconductor.org/biocLite.R")
biocLite("DEXSeq")
View(genes)
setwd("~/Desktop/RNAseq example/data")
targets <- read.delim("targets.txt")
View(targets)
￼library(Rsamtools)
library(Rsamtools)
dir.create("results") # Note: all output data will be written to directory 'results' system("bowtie2-build ./data/tair10chr.fasta ./data/tair10chr.fasta") # Build indexed reference genome targets <- read.delim("./data/targets.txt") # Import experiment design information
targets
setwd("~/Desktop/RNAseq example")
targets <- read.delim("./data/targets.txt")
library(Rsamtools)
dir.create("results") # Note: all output data will be written to directory 'results' system("bowtie2-build ./data/tair10chr.fasta ./data/tair10chr.fasta") # Build indexed reference genome targets <- read.delim("./data/targets.txt") # Import experiment design information
targets
input <- paste("./data", targets[,3], sep="")
input <- paste("./data/", targets[,3], sep="")
output <- paste("./results/", targets[,3], ".sam", sep="")
reference <- "./results/tair10chr.fasta"
for(i in seq(along=targets[,3])) {
command <- paste("bowtie2 -x ./data/tair10chr.fasta -U", input[i], "-S", output[i]) system(command)
asBam(file=output[i], destination=gsub(".sam", "", output[i]), overwrite=TRUE, indexDestination=T unlink(output[i])
}
for(i in seq(along=targets[,3])) {
command <- paste("bowtie2 -x ./data/tair10chr.fasta -U", input[i], "-S", output[i]) system(command)
asBam(file=output[i], destination=gsub(".sam", "", output[i]),
overwrite=TRUE, indexDestination=T,
unlink(output[i])
}
seq(along=targets[,3])
i=1
command <- paste("bowtie2 -x ./data/tair10chr.fasta -U", input[i], "-S", output[i])
system(command)
input
command <- paste("/opt/bowtie2-2.2.3//bowtie2 -x ./data/tair10chr.fasta -U", input[i], "-S", output[i])
system(command)
?asBam
asBam(file=output[i], destination=gsub(".sam", "", output[i]),
overwrite=TRUE, indexDestination=T,
unlink(output[i])
)
for(i in seq(along=targets[,3])) {
command <- paste("/opt/bowtie2-2.2.3//bowtie2 -x ./data/tair10chr.fasta -U", input[i], "-S", output[i])
system(command)
asBam(file=output[i], destination=gsub(".sam", "", output[i]),
overwrite=TRUE, indexDestination=T,
unlink(output[i]))
}
library(rtracklayer); library(GenomicRanges); library(Rsamtools)
install.packages("rtracklayer")
library(GenomicRanges); library(Rsamtools)
> gff <- import.gff("./data/TAIR10_GFF3_trunc.gff", asRangedData=FALSE)
gff <- import.gff("./data/TAIR10_GFF3_trunc.gff", asRangedData=FALSE)
source("http://bioconductor.org/biocLite.R")
biocLite("rtracklayer")
library(rtracklayer); library(GenomicRanges); library(Rsamtools)
gff <- import.gff("./data/TAIR10_GFF3_trunc.gff", asRangedData=FALSE)
seqlengths(gff) <- end(ranges(gff[which(elementMetadata(gff)[,"type"]=="chromosome"),])) > subgene_index <- which(elementMetadata(gff)[,"type"] == "exon")
seqlengths(gff) <- end(ranges(gff[which(elementMetadata(gff)[,"type"]=="chromosome"),]))
subgene_index <- which(elementMetadata(gff)[,"type"] == "exon")
gffsub <- gff[subgene_index,] # Returns only gene ranges
gffsub[1:4, c(2,5)]
ids <- gsub("Parent=|\\..*", "", elementMetadata(gffsub)$group)
gffsub <- split(gffsub, ids) # Coerce to GRangesList
bfl <- BamFileList("./results/", index=character())
countDF2 <- summarizeOverlaps(gffsub, bfl, mode="Union", ignore.strand=TRUE)
bfl <- BamFileList("./results/SRR064154.fastq.bam", index=character())
countDF2 <- summarizeOverlaps(gffsub, bfl, mode="Union", ignore.strand=TRUE)
countDF2 <- assays(countDF2)$counts
countDF2[1:4,]
x = rnorm(100)
x
shapiro.test(x)
shapiro.test(x)
shapiro.test(rnorm(1000))
shapiro.test(rnorm(1000))
shapiro.test(rnorm(1000))
?shapiro.test
shapiro.test(x=rnorm(1000))
shapiro.test(x=rnorm(1000, mean=0, sd=1))
shapiro.test(x=rnorm(1000, mean=0, sd=1))
ks.test(x,"pnorm",mean(x),sd(x))
ks.test(x>0,"pnorm",mean(x),sd(x))
ks.test(x[x>0],"pnorm",mean(x),sd(x))
shapiro.test(x[x>0],"pnorm",mean(x),sd(x))
shapiro.test(x[x>0])
library(ts)
install.packages("tsfa")
install.packages("ts")
install.packages("tseries")
library(tseries)
?tseries
help(tseries)
ts(x)
tx = ts(x, start=1, frequency=10)
plot(tx)
plot(stl(tx))
plot(stl(tx, s.window="periodic") )
lx = log(x)
t = seq(1956, 1995.2,length=length(x))
t
t2 = t^2
plot(x)
lm(x ~ t+t2)
lines(lm(x ~ t+t2)$fit, col=2,lwd=2)
plot(lx)
lines(lm(x ~ t+t2)$fit, col=2,lwd=2)
lines(lm(x ~ t+t2)$fit, col=2,lwd=2)
t3 = t^3
lines(lm(x ~ t+t2+t3)$fit, col=2,lwd=2)
sin.t<-sin(2*pi*t)cos.t<-cos(2*pi*t)
sin.t<-sin(2*pi*t)
cos.t<-cos(2*pi*t)
lines(lm(x ~ t+t2+sin.t+cos.t)$fit, col=2,lwd=2)
lines(lm(x ~ t+t2+sin.t+cos.t)$fit, col=4,lwd=2)
summary(lm(x ~ t+t2+sin.t+cos.t))
n=4;p=20
x=matrix(rnorm(n*p),ncol=p)
truebeta = rnorm(p, 0, 0.001)
truebeta[11] = rnorm(1, 1, 0.01)
truebeta[13] = rnorm(1, 1, 0.01)
truebeta[16] = rnorm(1, 1, 0.01)
tbeta = round(truebeta, digits = 2)
alpha=3;tau=2
eps=rnorm(n,0,1/sqrt(tau))
y=alpha+as.vector(x%*%tbeta + eps)
mod=lm(y~x)
print(summary(mod))
tbeta
library(glmnet)
fit = glmnet(W, y_scaled, standardize=F, intercept=F, lambda = 0.8, penalty.factor = rep(0,times = p))
y_scaled = y-mean(y)
W = sweep(x,2,colMeans(x))
solve(t(W)%*%W, t(W)%*%y)    # OLS
fit = glmnet(W, y_scaled, standardize=F, intercept=F, lambda = 0.8, penalty.factor = rep(0,times = p))
rep(0,times = p)
fit = glmnet(W, y_scaled, standardize=F, intercept=F, lambda = 0.8, penalty.factor = rep(0.1,times = p))
which(fit$beta != 0)
fit = glmnet(W, y_scaled, standardize=F, intercept=F, lambda = 0.8, penalty.factor = rep(0.3,times = p))
which(fit$beta != 0)
fit = glmnet(W, y_scaled, standardize=F, intercept=F, lambda = 0.8,
penalty.factor = rep(3,times = p))
which(fit$beta != 0)
fit = glmnet(W, y_scaled, standardize=F, intercept=F, lambda = 0.8,
penalty.factor = rep(0.001,times = p))
which(fit$beta != 0)
fit = glmnet(W, y_scaled, standardize=F, intercept=F, lambda = 0.8)
which(fit$beta != 0)
penalties = rep(1,times = p)
fit = glmnet(W, y_scaled, standardize=F, intercept=F, lambda = 0.8, penalty.factor = penalties)
which(fit$beta != 0)
penalties[5]= 0
fit = glmnet(W, y_scaled, standardize=F, intercept=F, lambda = 0.8, penalty.factor = penalties)
which(fit$beta != 0)
penalties[5]= penalties[20] = 0
fit = glmnet(W, y_scaled, standardize=F, intercept=F, lambda = 0.8, penalty.factor = penalties)
which(fit$beta != 0)
setwd("~/Documents/rcode/thr33some")
require(snowfall)
library(MASS)
GLIO_Methy_Expression <- read.delim("./data/GBM/GLIO_Methy_Expression.txt", header=F)
GLIO_Gene_Expression <- read.delim("./data/GBM/GLIO_Gene_Expression.txt", header=F)
GLIO_Survival <- read.delim("./data/GBM/GLIO_Survival.txt")
###                   load GBM expression
expr = as.data.frame(t(GLIO_Gene_Expression))
source("load_data.R")
source("build_expr_expr_net.R")
source("build_expr_methyl_net.R")
source("merge_results.R")
exprnet = build_expr_expr_net(exprdata, start=101, end=324,ncpu=4)
methnet = build_expr_methyl_net(exprdata=exprdata, methyldata=methyldata, start=1, end=500)
exprnet = build_expr_expr_net(exprdata, start=325, end=500,ncpu=4)
exprnet = build_expr_expr_net(exprdata, start=1, end=100,ncpu=4)
source("merge_results.R")
source("merge_results.R")
source("merge_results.R")
mergeResults(ee = F, em=T, plot=F)
mergeResults(ee = F, em=T, plot=T)
source("merge_results.R")
mergeResults(ee = F, em=T, plot=F)
source("merge_results.R")
mergeResults(ee = F, em=T, plot=F)
mergeResults(ee = T, em=F, plot=F)
source("merge_results.R")
mergeResults(ee = T, em=F, plot=F)
source("merge_results.R")
mergeResults(ee = T, em=T, plot=F)
makegraph(exprnet, outfile = "nofile", plot = T)
makegraph(methnet, outfile = "nofile", plot = T)
View(methnet)
View(exprnet)
